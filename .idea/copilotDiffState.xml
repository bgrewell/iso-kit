<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/pkg/iso9660/boot/eltorito.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pkg/iso9660/boot/eltorito.go" />
              <option name="originalContent" value="package boot&#10;&#10;import (&#10;&#9;&quot;encoding/binary&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/bgrewell/iso-kit/pkg/consts&quot;&#10;&#9;&quot;github.com/bgrewell/iso-kit/pkg/filesystem&quot;&#10;&#9;&quot;github.com/bgrewell/iso-kit/pkg/iso9660/info&quot;&#10;&#9;&quot;github.com/bgrewell/iso-kit/pkg/logging&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;const (&#10;&#9;// Logical sector 17 containing El-Torito boot catalog&#10;&#9;EL_TORITO_SECTOR = 0x11&#10;&#9;// Default catalog name for non-Rock Ridge filesystems&#10;&#9;EL_TORITO_DEFAULT_CATALOG = &quot;BOOT.CAT&quot;&#10;&#9;// Default catalog name for Rock Ridge filesystems&#10;&#9;EL_TORITO_DEFAULT_CATALOG_RR = &quot;boot.catalog&quot;&#10;)&#10;&#10;// PartitionType represents the type of partition in the boot image.&#10;type PartitionType byte&#10;&#10;// List of GUID partition types&#10;const (&#10;&#9;Empty         PartitionType = 0x00&#10;&#9;Fat12         PartitionType = 0x01&#10;&#9;XenixRoot     PartitionType = 0x02&#10;&#9;XenixUsr      PartitionType = 0x03&#10;&#9;Fat16         PartitionType = 0x04&#10;&#9;ExtendedCHS   PartitionType = 0x05&#10;&#9;Fat16b        PartitionType = 0x06&#10;&#9;NTFS          PartitionType = 0x07&#10;&#9;CommodoreFAT  PartitionType = 0x08&#10;&#9;Fat32CHS      PartitionType = 0x0b&#10;&#9;Fat32LBA      PartitionType = 0x0c&#10;&#9;Fat16bLBA     PartitionType = 0x0e&#10;&#9;ExtendedLBA   PartitionType = 0x0f&#10;&#9;Linux         PartitionType = 0x83&#10;&#9;LinuxExtended PartitionType = 0x85&#10;&#9;LinuxLVM      PartitionType = 0x8e&#10;&#9;Iso9660       PartitionType = 0x96&#10;&#9;MacOSXUFS     PartitionType = 0xa8&#10;&#9;MacOSXBoot    PartitionType = 0xab&#10;&#9;HFS           PartitionType = 0xaf&#10;&#9;Solaris8Boot  PartitionType = 0xbe&#10;&#9;//GPTProtective PartitionType = 0xef&#10;&#9;EFISystem  PartitionType = 0xef&#10;&#9;VMWareFS   PartitionType = 0xfb&#10;&#9;VMWareSwap PartitionType = 0xfc&#10;)&#10;&#10;func (p PartitionType) String() string {&#10;&#9;switch p {&#10;&#9;case Empty:&#10;&#9;&#9;return &quot;Empty&quot;&#10;&#9;case Fat12:&#10;&#9;&#9;return &quot;FAT12&quot;&#10;&#9;case XenixRoot:&#10;&#9;&#9;return &quot;Xenix Root&quot;&#10;&#9;case XenixUsr:&#10;&#9;&#9;return &quot;Xenix User&quot;&#10;&#9;case Fat16:&#10;&#9;&#9;return &quot;FAT16&quot;&#10;&#9;case ExtendedCHS:&#10;&#9;&#9;return &quot;Extended (CHS)&quot;&#10;&#9;case Fat16b:&#10;&#9;&#9;return &quot;FAT16B&quot;&#10;&#9;case NTFS:&#10;&#9;&#9;return &quot;NTFS&quot;&#10;&#9;case CommodoreFAT:&#10;&#9;&#9;return &quot;Commodore FAT&quot;&#10;&#9;case Fat32CHS:&#10;&#9;&#9;return &quot;FAT32 (CHS)&quot;&#10;&#9;case Fat32LBA:&#10;&#9;&#9;return &quot;FAT32 (LBA)&quot;&#10;&#9;case Fat16bLBA:&#10;&#9;&#9;return &quot;FAT16B (LBA)&quot;&#10;&#9;case ExtendedLBA:&#10;&#9;&#9;return &quot;Extended (LBA)&quot;&#10;&#9;case Linux:&#10;&#9;&#9;return &quot;Linux&quot;&#10;&#9;case LinuxExtended:&#10;&#9;&#9;return &quot;Linux Extended&quot;&#10;&#9;case LinuxLVM:&#10;&#9;&#9;return &quot;Linux LVM&quot;&#10;&#9;case Iso9660:&#10;&#9;&#9;return &quot;ISO9660&quot;&#10;&#9;case MacOSXUFS:&#10;&#9;&#9;return &quot;MacOS X UFS&quot;&#10;&#9;case MacOSXBoot:&#10;&#9;&#9;return &quot;MacOS X Boot&quot;&#10;&#9;case HFS:&#10;&#9;&#9;return &quot;HFS&quot;&#10;&#9;case Solaris8Boot:&#10;&#9;&#9;return &quot;Solaris 8 Boot&quot;&#10;&#9;case EFISystem:&#10;&#9;&#9;return &quot;EFI System&quot;&#10;&#9;case VMWareFS:&#10;&#9;&#9;return &quot;VMWare FS&quot;&#10;&#9;case VMWareSwap:&#10;&#9;&#9;return &quot;VMWare Swap&quot;&#10;&#9;default:&#10;&#9;&#9;return &quot;Unknown&quot;&#10;&#9;}&#10;}&#10;&#10;// Platform represents the target booting system for an El-Torito bootable ISO.&#10;type Platform uint8&#10;&#10;const (&#10;&#9;BIOS Platform = 0x0  // Classic PC-BIOS x86&#10;&#9;PPC  Platform = 0x1  // PowerPC&#10;&#9;Mac  Platform = 0x2  // Macintosh systems&#10;&#9;EFI  Platform = 0xef // Extensible Firmware Interface (EFI)&#10;)&#10;&#10;func (p Platform) String() string {&#10;&#9;switch p {&#10;&#9;case BIOS:&#10;&#9;&#9;return &quot;BIOS&quot;&#10;&#9;case PPC:&#10;&#9;&#9;return &quot;PowerPC&quot;&#10;&#9;case Mac:&#10;&#9;&#9;return &quot;Macintosh&quot;&#10;&#9;case EFI:&#10;&#9;&#9;return &quot;EFI&quot;&#10;&#9;default:&#10;&#9;&#9;return &quot;Unknown&quot;&#10;&#9;}&#10;}&#10;&#10;// Emulation represents the emulation mode used for booting.&#10;type Emulation uint8&#10;&#10;const (&#10;&#9;NoEmulation        Emulation = 0x0 // No emulation (default)&#10;&#9;Floppy12Emulation  Emulation = 0x1 // Emulate a 1.2 MB floppy&#10;&#9;Floppy144Emulation Emulation = 0x2 // Emulate a 1.44 MB floppy&#10;&#9;Floppy288Emulation Emulation = 0x3 // Emulate a 2.88 MB floppy&#10;&#9;HardDiskEmulation  Emulation = 0x4 // Emulate a hard disk&#10;)&#10;&#10;func (e Emulation) String() string {&#10;&#9;switch e {&#10;&#9;case NoEmulation:&#10;&#9;&#9;return &quot;NoEmul&quot;&#10;&#9;case Floppy12Emulation:&#10;&#9;&#9;return &quot;1.2MFloppy&quot;&#10;&#9;case Floppy144Emulation:&#10;&#9;&#9;return &quot;1.44MFloppy&quot;&#10;&#9;case Floppy288Emulation:&#10;&#9;&#9;return &quot;2.88MFloppy&quot;&#10;&#9;case HardDiskEmulation:&#10;&#9;&#9;return &quot;HardDisk&quot;&#10;&#9;default:&#10;&#9;&#9;return &quot;Unknown&quot;&#10;&#9;}&#10;}&#10;&#10;// ElTorito represents the El-Torito boot structure for a disk.&#10;type ElTorito struct {&#10;&#9;BootCatalog     string           // Path to the boot catalog file&#10;&#9;HideBootCatalog bool             // Whether to hide the boot catalog in the filesystem&#10;&#9;Entries         []*ElToritoEntry // List of El-Torito boot entries&#10;&#9;Platform        Platform         // Target platform for booting&#10;&#9;// Object Location (in bytes)&#10;&#9;ObjectLocation int64 `json:&quot;object_location&quot;`&#10;&#9;// Object Size (in bytes)&#10;&#9;ObjectSize uint32          `json:&quot;object_size&quot;`&#10;&#9;Logger     *logging.Logger // Logger for debug output&#10;}&#10;&#10;func (et *ElTorito) Type() string {&#10;&#9;return &quot;Boot Catalog&quot;&#10;}&#10;&#10;func (et *ElTorito) Name() string {&#10;&#9;return &quot;El Torito Boot Catalog&quot;&#10;}&#10;&#10;func (et *ElTorito) Description() string {&#10;&#9;return fmt.Sprintf(&quot;%s Entries: %d&quot;, et.BootCatalog, len(et.Entries))&#10;}&#10;&#10;func (et *ElTorito) Properties() map[string]interface{} {&#10;&#10;&#9;type EntryDetails struct {&#10;&#9;&#9;Emulation     string&#10;&#9;&#9;Platform      string&#10;&#9;&#9;PartitionType string&#10;&#9;&#9;Location      uint32&#10;&#9;&#9;Size          uint16&#10;&#9;}&#10;&#10;&#9;entryDetails := make(map[string]EntryDetails)&#10;&#9;if len(et.Entries) &gt; 0 {&#10;&#9;&#9;for _, entry := range et.Entries {&#10;&#9;&#9;&#9;entryDetails[entry.BootFile] = EntryDetails{&#10;&#9;&#9;&#9;&#9;Emulation:     entry.Emulation.String(),&#10;&#9;&#9;&#9;&#9;Platform:      entry.Platform.String(),&#10;&#9;&#9;&#9;&#9;PartitionType: entry.PartitionType.String(),&#10;&#9;&#9;&#9;&#9;Location:      entry.location,&#10;&#9;&#9;&#9;&#9;Size:          entry.size,&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return map[string]interface{}{&#10;&#9;&#9;&quot;Entries&quot;:         len(et.Entries),&#10;&#9;&#9;&quot;Platform&quot;:        et.Platform,&#10;&#9;&#9;&quot;HideBootCatalog&quot;: et.HideBootCatalog,&#10;&#9;&#9;&quot;EntryDetails&quot;:    entryDetails,&#10;&#9;}&#10;}&#10;&#10;func (et *ElTorito) Offset() int64 {&#10;&#9;return et.ObjectLocation&#10;}&#10;&#10;func (et *ElTorito) Size() int {&#10;&#9;return int(et.ObjectSize)&#10;}&#10;&#10;func (et *ElTorito) GetObjects() []info.ImageObject {&#10;&#9;return []info.ImageObject{et}&#10;}&#10;&#10;func (et *ElTorito) Marshal() ([]byte, error) {&#10;&#9;if len(et.Entries) == 0 {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;El Torito Boot Catalog has no entries&quot;)&#10;&#9;}&#10;&#10;&#9;// Boot Catalog is stored in 2048-byte sectors, ensure correct alignment&#10;&#9;data := make([]byte, consts.ISO9660_SECTOR_SIZE)&#10;&#10;&#9;// 1️⃣ Write Validation Entry (First 32 bytes)&#10;&#9;data[0] = 0x01                    // Header ID&#10;&#9;copy(data[1:6], &quot;EL TORITO SPEC&quot;) // Identifier&#10;&#9;data[0x1E] = 0x55&#10;&#9;data[0x1F] = 0xAA&#10;&#10;&#9;// Compute checksum&#10;&#9;checksum := uint16(0)&#10;&#9;for i := 0; i &lt; 32; i += 2 {&#10;&#9;&#9;checksum += binary.LittleEndian.Uint16(data[i : i+2])&#10;&#9;}&#10;&#9;binary.LittleEndian.PutUint16(data[0x1C:0x1E], -checksum) // Store negative checksum&#10;&#10;&#9;// 2️⃣ Write Initial Boot Entry (First Boot Entry, starts at offset 32)&#10;&#9;offset := 32&#10;&#9;for _, entry := range et.Entries {&#10;&#9;&#9;if offset+32 &gt; len(data) {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;Boot catalog exceeds sector size limit&quot;)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;data[offset] = 0x88                    // Boot Indicator (0x88 = Bootable)&#10;&#9;&#9;data[offset+1] = byte(entry.Platform)  // Platform ID&#10;&#9;&#9;data[offset+2] = byte(entry.Emulation) // Emulation Type&#10;&#9;&#9;binary.LittleEndian.PutUint16(data[offset+4:], entry.LoadSegment)&#10;&#9;&#9;binary.LittleEndian.PutUint16(data[offset+6:], entry.size)     // Size in 512-byte blocks&#10;&#9;&#9;binary.LittleEndian.PutUint32(data[offset+8:], entry.location) // Location in 2048-byte sectors&#10;&#10;&#9;&#9;offset += 32 // Move to next entry&#10;&#9;}&#10;&#10;&#9;return data, nil&#10;}&#10;&#10;// UnmarshalBinary decodes an El-Torito Boot Catalog from binary form&#10;func (et *ElTorito) UnmarshalBinary(data []byte) error {&#10;&#9;if len(data) &lt; 32 {&#10;&#9;&#9;return fmt.Errorf(&quot;Boot Catalog: data too short&quot;)&#10;&#9;}&#10;&#10;&#9;// Parse Validation Entry&#10;&#9;if err := parseValidationEntry(data[:32]); err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;Boot Catalog: invalid Validation Entry: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Parse Boot Entries&#10;&#9;sectionCount := 0&#10;&#9;for offset := 32; offset &lt; len(data); offset += 32 {&#10;&#9;&#9;entryData := data[offset : offset+32]&#10;&#10;&#9;&#9;// Check for End of Catalog&#10;&#9;&#9;if entryData[0] == 0x00 {&#10;&#9;&#9;&#9;break&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Handle Section Headers&#10;&#9;&#9;if entryData[0] == 0x90 || entryData[0] == 0x91 {&#10;&#9;&#9;&#9;sectionCount = int(binary.LittleEndian.Uint16(entryData[2:4]))&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Parse Section Entries&#10;&#9;&#9;if sectionCount &gt; 0 {&#10;&#9;&#9;&#9;entry := parseSectionEntry(entryData)&#10;&#9;&#9;&#9;et.Entries = append(et.Entries, entry)&#10;&#9;&#9;&#9;sectionCount--&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Parse Initial/Default Entry&#10;&#9;&#9;entry := parseInitialEntry(entryData)&#10;&#9;&#9;et.Entries = append(et.Entries, entry)&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;// ElToritoEntry represents a single entry in an El-Torito boot catalog.&#10;type ElToritoEntry struct {&#10;&#9;Platform      Platform      // Target platform&#10;&#9;Emulation     Emulation     // Emulation mode&#10;&#9;BootFile      string        // Path to the boot file&#10;&#9;HideBootFile  bool          // Whether to hide the boot file in the filesystem&#10;&#9;LoadSegment   uint16        // Open segment address&#10;&#9;PartitionType PartitionType // Partition type of the boot file&#10;&#9;size          uint16        // Size of the boot file in 512-byte blocks&#10;&#9;location      uint32        // Location of the boot file in 2048-byte sectors&#10;}&#10;&#10;// SectionHeader represents a header for grouping entries in the boot catalog.&#10;type SectionHeader struct {&#10;&#9;Indicator byte     // Indicator byte (0x90 or 0x91 for the last section)&#10;&#9;Platform  Platform // Target platform&#10;&#9;Entries   uint16   // Number of entries in the section&#10;}&#10;&#10;// SelectionCriteria represents optional vendor-specific selection criteria.&#10;type SelectionCriteria struct {&#10;&#9;Type       byte   // Selection criteria type&#10;&#9;VendorData []byte // Vendor-specific data&#10;}&#10;&#10;// ValidationEntry represents the validation entry at the start of the boot catalog.&#10;type ValidationEntry struct {&#10;&#9;Platform    Platform // Target platform&#10;&#9;Identifier  string   // Identifier string&#10;&#9;Checksum    uint16   // Validation checksum&#10;&#9;KeyByte55AA uint16   // Fixed 0x55AA marker&#10;}&#10;&#10;// BuildBootImageEntries constructs a list of FileSystemEntry objects for all boot images.&#10;func (et *ElTorito) BuildBootImageEntries() ([]*filesystem.FileSystemEntry, error) {&#10;&#9;var entries []*filesystem.FileSystemEntry&#10;&#10;&#9;for i, entry := range et.Entries {&#10;&#9;&#9;// Skip non-bootable entries&#10;&#9;&#9;if entry.size == 0 || entry.location == 0 {&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Construct a synthetic file name for the boot image&#10;&#9;&#9;filename := fmt.Sprintf(&quot;%d-Boot-%s.img&quot;, i+1, entry.Emulation)&#10;&#10;&#9;&#9;// TODO: The directory should be user configurable, for now we use the same default as 7z&#10;&#9;&#9;// Create a FileSystemEntry for the boot image&#10;&#9;&#9;fsEntry := &amp;filesystem.FileSystemEntry{&#10;&#9;&#9;&#9;Name:       filename,&#10;&#9;&#9;&#9;FullPath:   &quot;/[BOOT]/&quot; + filename, // Logical path inside the ISO&#10;&#9;&#9;&#9;IsDir:      false,&#10;&#9;&#9;&#9;Size:       uint32(entry.size * 512), // Convert 512-byte block size&#10;&#9;&#9;&#9;Location:   entry.location,&#10;&#9;&#9;&#9;Mode:       0444,        // Read-only boot image&#10;&#9;&#9;&#9;CreateTime: time.Time{}, // No real timestamp in El Torito&#10;&#9;&#9;&#9;ModTime:    time.Time{},&#10;&#9;&#9;&#9;UID:        nil,&#10;&#9;&#9;&#9;GID:        nil,&#10;&#9;&#9;}&#10;&#10;&#9;&#9;entries = append(entries, fsEntry)&#10;&#9;}&#10;&#10;&#9;return entries, nil&#10;}&#10;&#10;// ExtractBootImages extracts all bootable images to the specified directory.&#10;func (et *ElTorito) ExtractBootImages(ra io.ReaderAt, outputDir string) error {&#10;&#9;for i, entry := range et.Entries {&#10;&#9;&#9;// Skip non-bootable entries&#10;&#9;&#9;if entry.size == 0 || entry.location == 0 {&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Create the file name&#10;&#9;&#9;filename := fmt.Sprintf(&quot;%d-Boot-%s.img&quot;, i+1, entry.Emulation)&#10;&#9;&#9;outputPath := filepath.Join(outputDir, filename)&#10;&#10;&#9;&#9;// Open the output file for writing&#10;&#9;&#9;outFile, err := os.Create(outputPath)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;failed to create file %s: %w&quot;, outputPath, err)&#10;&#9;&#9;}&#10;&#9;&#9;defer outFile.Close()&#10;&#10;&#9;&#9;// Read the boot image data&#10;&#9;&#9;startOffset := int64(entry.location) * int64(consts.ISO9660_SECTOR_SIZE)&#10;&#9;&#9;data := make([]byte, int64(entry.size)*512) // Size is in 512-byte blocks&#10;&#9;&#9;if _, err := ra.ReadAt(data, startOffset); err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;failed to read boot image at offset %d: %w&quot;, startOffset, err)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Write the data to the file&#10;&#9;&#9;if _, err := outFile.Write(data); err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;failed to write boot image to file %s: %w&quot;, outputPath, err)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Save the boot file path in the entry&#10;&#9;&#9;entry.BootFile = outputPath&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;func IsElTorito(bootSystemIdentifier string) bool {&#10;&#9;trimmed := strings.TrimRight(bootSystemIdentifier, &quot;\x00&quot;)&#10;&#9;return trimmed == consts.EL_TORITO_BOOT_SYSTEM_ID&#10;}&#10;&#10;func parseInitialEntry(data []byte) *ElToritoEntry {&#10;&#9;return &amp;ElToritoEntry{&#10;&#9;&#9;Platform:      Platform(data[1]),&#10;&#9;&#9;Emulation:     Emulation(data[2]),&#10;&#9;&#9;LoadSegment:   binary.LittleEndian.Uint16(data[4:6]),&#10;&#9;&#9;PartitionType: PartitionType(data[4]),&#10;&#9;&#9;size:          binary.LittleEndian.Uint16(data[6:8]),&#10;&#9;&#9;location:      binary.LittleEndian.Uint32(data[8:12]),&#10;&#9;}&#10;}&#10;&#10;func parseSectionEntry(data []byte) *ElToritoEntry {&#10;&#9;return &amp;ElToritoEntry{&#10;&#9;&#9;Platform:      Platform(data[1]),&#10;&#9;&#9;Emulation:     Emulation(data[2]),&#10;&#9;&#9;LoadSegment:   binary.LittleEndian.Uint16(data[4:6]),&#10;&#9;&#9;PartitionType: PartitionType(data[4]),&#10;&#9;&#9;size:          binary.LittleEndian.Uint16(data[6:8]),&#10;&#9;&#9;location:      binary.LittleEndian.Uint32(data[8:12]),&#10;&#9;}&#10;}&#10;&#10;func parseValidationEntry(data []byte) error {&#10;&#9;if len(data) &lt; 32 {&#10;&#9;&#9;return fmt.Errorf(&quot;Validation Entry: data too short&quot;)&#10;&#9;}&#10;&#9;if data[0] != 0x01 {&#10;&#9;&#9;return fmt.Errorf(&quot;Validation Entry: invalid header ID %x&quot;, data[0])&#10;&#9;}&#10;&#9;checksum := uint16(0)&#10;&#9;for i := 0; i &lt; 32; i += 2 {&#10;&#9;&#9;checksum += binary.LittleEndian.Uint16(data[i : i+2])&#10;&#9;}&#10;&#9;if checksum != 0 {&#10;&#9;&#9;return fmt.Errorf(&quot;Validation Entry: checksum invalid&quot;)&#10;&#9;}&#10;&#9;if data[0x1E] != 0x55 || data[0x1F] != 0xAA {&#10;&#9;&#9;return fmt.Errorf(&quot;Validation Entry: invalid key bytes %x%x&quot;, data[0x1E], data[0x1F])&#10;&#9;}&#10;&#9;return nil&#10;}&#10;" />
              <option name="updatedContent" value="package boot&#10;&#10;import (&#10;&#9;&quot;encoding/binary&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/bgrewell/iso-kit/pkg/consts&quot;&#10;&#9;&quot;github.com/bgrewell/iso-kit/pkg/filesystem&quot;&#10;&#9;&quot;github.com/bgrewell/iso-kit/pkg/iso9660/info&quot;&#10;&#9;&quot;github.com/bgrewell/iso-kit/pkg/logging&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;const (&#10;&#9;// Logical sector 17 containing El-Torito boot catalog&#10;&#9;EL_TORITO_SECTOR = 0x11&#10;&#9;// Default catalog name for non-Rock Ridge filesystems&#10;&#9;EL_TORITO_DEFAULT_CATALOG = &quot;BOOT.CAT&quot;&#10;&#9;// Default catalog name for Rock Ridge filesystems&#10;&#9;EL_TORITO_DEFAULT_CATALOG_RR = &quot;boot.catalog&quot;&#10;)&#10;&#10;// PartitionType represents the type of partition in the boot image.&#10;type PartitionType byte&#10;&#10;// List of GUID partition types&#10;const (&#10;&#9;Empty         PartitionType = 0x00&#10;&#9;Fat12         PartitionType = 0x01&#10;&#9;XenixRoot     PartitionType = 0x02&#10;&#9;XenixUsr      PartitionType = 0x03&#10;&#9;Fat16         PartitionType = 0x04&#10;&#9;ExtendedCHS   PartitionType = 0x05&#10;&#9;Fat16b        PartitionType = 0x06&#10;&#9;NTFS          PartitionType = 0x07&#10;&#9;CommodoreFAT  PartitionType = 0x08&#10;&#9;Fat32CHS      PartitionType = 0x0b&#10;&#9;Fat32LBA      PartitionType = 0x0c&#10;&#9;Fat16bLBA     PartitionType = 0x0e&#10;&#9;ExtendedLBA   PartitionType = 0x0f&#10;&#9;Linux         PartitionType = 0x83&#10;&#9;LinuxExtended PartitionType = 0x85&#10;&#9;LinuxLVM      PartitionType = 0x8e&#10;&#9;Iso9660       PartitionType = 0x96&#10;&#9;MacOSXUFS     PartitionType = 0xa8&#10;&#9;MacOSXBoot    PartitionType = 0xab&#10;&#9;HFS           PartitionType = 0xaf&#10;&#9;Solaris8Boot  PartitionType = 0xbe&#10;&#9;//GPTProtective PartitionType = 0xef&#10;&#9;EFISystem  PartitionType = 0xef&#10;&#9;VMWareFS   PartitionType = 0xfb&#10;&#9;VMWareSwap PartitionType = 0xfc&#10;)&#10;&#10;func (p PartitionType) String() string {&#10;&#9;switch p {&#10;&#9;case Empty:&#10;&#9;&#9;return &quot;Empty&quot;&#10;&#9;case Fat12:&#10;&#9;&#9;return &quot;FAT12&quot;&#10;&#9;case XenixRoot:&#10;&#9;&#9;return &quot;Xenix Root&quot;&#10;&#9;case XenixUsr:&#10;&#9;&#9;return &quot;Xenix User&quot;&#10;&#9;case Fat16:&#10;&#9;&#9;return &quot;FAT16&quot;&#10;&#9;case ExtendedCHS:&#10;&#9;&#9;return &quot;Extended (CHS)&quot;&#10;&#9;case Fat16b:&#10;&#9;&#9;return &quot;FAT16B&quot;&#10;&#9;case NTFS:&#10;&#9;&#9;return &quot;NTFS&quot;&#10;&#9;case CommodoreFAT:&#10;&#9;&#9;return &quot;Commodore FAT&quot;&#10;&#9;case Fat32CHS:&#10;&#9;&#9;return &quot;FAT32 (CHS)&quot;&#10;&#9;case Fat32LBA:&#10;&#9;&#9;return &quot;FAT32 (LBA)&quot;&#10;&#9;case Fat16bLBA:&#10;&#9;&#9;return &quot;FAT16B (LBA)&quot;&#10;&#9;case ExtendedLBA:&#10;&#9;&#9;return &quot;Extended (LBA)&quot;&#10;&#9;case Linux:&#10;&#9;&#9;return &quot;Linux&quot;&#10;&#9;case LinuxExtended:&#10;&#9;&#9;return &quot;Linux Extended&quot;&#10;&#9;case LinuxLVM:&#10;&#9;&#9;return &quot;Linux LVM&quot;&#10;&#9;case Iso9660:&#10;&#9;&#9;return &quot;ISO9660&quot;&#10;&#9;case MacOSXUFS:&#10;&#9;&#9;return &quot;MacOS X UFS&quot;&#10;&#9;case MacOSXBoot:&#10;&#9;&#9;return &quot;MacOS X Boot&quot;&#10;&#9;case HFS:&#10;&#9;&#9;return &quot;HFS&quot;&#10;&#9;case Solaris8Boot:&#10;&#9;&#9;return &quot;Solaris 8 Boot&quot;&#10;&#9;case EFISystem:&#10;&#9;&#9;return &quot;EFI System&quot;&#10;&#9;case VMWareFS:&#10;&#9;&#9;return &quot;VMWare FS&quot;&#10;&#9;case VMWareSwap:&#10;&#9;&#9;return &quot;VMWare Swap&quot;&#10;&#9;default:&#10;&#9;&#9;return &quot;Unknown&quot;&#10;&#9;}&#10;}&#10;&#10;// Platform represents the target booting system for an El-Torito bootable ISO.&#10;type Platform uint8&#10;&#10;const (&#10;&#9;BIOS Platform = 0x0  // Classic PC-BIOS x86&#10;&#9;PPC  Platform = 0x1  // PowerPC&#10;&#9;Mac  Platform = 0x2  // Macintosh systems&#10;&#9;EFI  Platform = 0xef // Extensible Firmware Interface (EFI)&#10;)&#10;&#10;func (p Platform) String() string {&#10;&#9;switch p {&#10;&#9;case BIOS:&#10;&#9;&#9;return &quot;BIOS&quot;&#10;&#9;case PPC:&#10;&#9;&#9;return &quot;PowerPC&quot;&#10;&#9;case Mac:&#10;&#9;&#9;return &quot;Macintosh&quot;&#10;&#9;case EFI:&#10;&#9;&#9;return &quot;EFI&quot;&#10;&#9;default:&#10;&#9;&#9;return &quot;Unknown&quot;&#10;&#9;}&#10;}&#10;&#10;// Emulation represents the emulation mode used for booting.&#10;type Emulation uint8&#10;&#10;const (&#10;&#9;NoEmulation        Emulation = 0x0 // No emulation (default)&#10;&#9;Floppy12Emulation  Emulation = 0x1 // Emulate a 1.2 MB floppy&#10;&#9;Floppy144Emulation Emulation = 0x2 // Emulate a 1.44 MB floppy&#10;&#9;Floppy288Emulation Emulation = 0x3 // Emulate a 2.88 MB floppy&#10;&#9;HardDiskEmulation  Emulation = 0x4 // Emulate a hard disk&#10;)&#10;&#10;func (e Emulation) String() string {&#10;&#9;switch e {&#10;&#9;case NoEmulation:&#10;&#9;&#9;return &quot;NoEmul&quot;&#10;&#9;case Floppy12Emulation:&#10;&#9;&#9;return &quot;1.2MFloppy&quot;&#10;&#9;case Floppy144Emulation:&#10;&#9;&#9;return &quot;1.44MFloppy&quot;&#10;&#9;case Floppy288Emulation:&#10;&#9;&#9;return &quot;2.88MFloppy&quot;&#10;&#9;case HardDiskEmulation:&#10;&#9;&#9;return &quot;HardDisk&quot;&#10;&#9;default:&#10;&#9;&#9;return &quot;Unknown&quot;&#10;&#9;}&#10;}&#10;&#10;// ElTorito represents the El-Torito boot structure for a disk.&#10;type ElTorito struct {&#10;&#9;BootCatalog     string           // Path to the boot catalog file&#10;&#9;HideBootCatalog bool             // Whether to hide the boot catalog in the filesystem&#10;&#9;Entries         []*ElToritoEntry // List of El-Torito boot entries&#10;&#9;Platform        Platform         // Target platform for booting&#10;&#9;// Object Location (in bytes)&#10;&#9;ObjectLocation int64 `json:&quot;object_location&quot;`&#10;&#9;// Object Size (in bytes)&#10;&#9;ObjectSize uint32          `json:&quot;object_size&quot;`&#10;&#9;Logger     *logging.Logger // Logger for debug output&#10;}&#10;&#10;func (et *ElTorito) Type() string {&#10;&#9;return &quot;Boot Catalog&quot;&#10;}&#10;&#10;func (et *ElTorito) Name() string {&#10;&#9;return &quot;El Torito Boot Catalog&quot;&#10;}&#10;&#10;func (et *ElTorito) Description() string {&#10;&#9;return fmt.Sprintf(&quot;%s Entries: %d&quot;, et.BootCatalog, len(et.Entries))&#10;}&#10;&#10;func (et *ElTorito) Properties() map[string]interface{} {&#10;&#10;&#9;type EntryDetails struct {&#10;&#9;&#9;Emulation     string&#10;&#9;&#9;Platform      string&#10;&#9;&#9;PartitionType string&#10;&#9;&#9;Location      uint32&#10;&#9;&#9;Size          uint16&#10;&#9;}&#10;&#10;&#9;entryDetails := make(map[string]EntryDetails)&#10;&#9;if len(et.Entries) &gt; 0 {&#10;&#9;&#9;for _, entry := range et.Entries {&#10;&#9;&#9;&#9;entryDetails[entry.BootFile] = EntryDetails{&#10;&#9;&#9;&#9;&#9;Emulation:     entry.Emulation.String(),&#10;&#9;&#9;&#9;&#9;Platform:      entry.Platform.String(),&#10;&#9;&#9;&#9;&#9;PartitionType: entry.PartitionType.String(),&#10;&#9;&#9;&#9;&#9;Location:      entry.location,&#10;&#9;&#9;&#9;&#9;Size:          entry.size,&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return map[string]interface{}{&#10;&#9;&#9;&quot;Entries&quot;:         len(et.Entries),&#10;&#9;&#9;&quot;Platform&quot;:        et.Platform,&#10;&#9;&#9;&quot;HideBootCatalog&quot;: et.HideBootCatalog,&#10;&#9;&#9;&quot;EntryDetails&quot;:    entryDetails,&#10;&#9;}&#10;}&#10;&#10;func (et *ElTorito) Offset() int64 {&#10;&#9;return et.ObjectLocation&#10;}&#10;&#10;func (et *ElTorito) Size() int {&#10;&#9;return int(et.ObjectSize)&#10;}&#10;&#10;func (et *ElTorito) GetObjects() []info.ImageObject {&#10;&#9;return []info.ImageObject{et}&#10;}&#10;&#10;func (et *ElTorito) Marshal() ([]byte, error) {&#10;&#9;if len(et.Entries) == 0 {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;El Torito Boot Catalog has no entries&quot;)&#10;&#9;}&#10;&#10;&#9;// Boot Catalog is stored in 2048-byte sectors, ensure correct alignment&#10;&#9;data := make([]byte, consts.ISO9660_SECTOR_SIZE)&#10;&#10;&#9;// 1️⃣ Write Validation Entry (First 32 bytes)&#10;&#9;data[0] = 0x01                    // Header ID&#10;&#9;copy(data[1:6], &quot;EL TORITO SPEC&quot;) // Identifier&#10;&#9;data[0x1E] = 0x55&#10;&#9;data[0x1F] = 0xAA&#10;&#10;&#9;// Compute checksum&#10;&#9;checksum := uint16(0)&#10;&#9;for i := 0; i &lt; 32; i += 2 {&#10;&#9;&#9;checksum += binary.LittleEndian.Uint16(data[i : i+2])&#10;&#9;}&#10;&#9;binary.LittleEndian.PutUint16(data[0x1C:0x1E], -checksum) // Store negative checksum&#10;&#10;&#9;// 2️⃣ Write Initial Boot Entry (First Boot Entry, starts at offset 32)&#10;&#9;offset := 32&#10;&#9;for _, entry := range et.Entries {&#10;&#9;&#9;if offset+32 &gt; len(data) {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;Boot catalog exceeds sector size limit&quot;)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;data[offset] = 0x88                    // Boot Indicator (0x88 = Bootable)&#10;&#9;&#9;data[offset+1] = byte(entry.Platform)  // Platform ID&#10;&#9;&#9;data[offset+2] = byte(entry.Emulation) // Emulation Type&#10;&#9;&#9;binary.LittleEndian.PutUint16(data[offset+4:], entry.LoadSegment)&#10;&#9;&#9;binary.LittleEndian.PutUint16(data[offset+6:], entry.size)     // Size in 512-byte blocks&#10;&#9;&#9;binary.LittleEndian.PutUint32(data[offset+8:], entry.location) // Location in 2048-byte sectors&#10;&#10;&#9;&#9;offset += 32 // Move to next entry&#10;&#9;}&#10;&#10;&#9;return data, nil&#10;}&#10;&#10;// UnmarshalBinary decodes an El-Torito Boot Catalog from binary form&#10;func (et *ElTorito) UnmarshalBinary(data []byte) error {&#10;&#9;if et.Logger != nil {&#10;&#9;&#9;et.Logger.Debug(&quot;Starting El Torito Boot Catalog unmarshalling&quot;)&#10;&#9;}&#10;&#9;if len(data) &lt; 32 {&#10;&#9;&#9;err := fmt.Errorf(&quot;Boot Catalog: data too short&quot;)&#10;&#9;&#9;if et.Logger != nil {&#10;&#9;&#9;&#9;et.Logger.Error(err, &quot;Boot Catalog: data too short&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// Parse Validation Entry&#10;&#9;err := parseValidationEntry(data[:32])&#10;&#9;if err != nil {&#10;&#9;&#9;if et.Logger != nil {&#10;&#9;&#9;&#9;et.Logger.Error(err, &quot;Boot Catalog: invalid Validation Entry&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;return fmt.Errorf(&quot;Boot Catalog: invalid Validation Entry: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Parse Boot Entries&#10;&#9;sectionCount := 0&#10;&#9;for offset := 32; offset &lt; len(data); offset += 32 {&#10;&#9;&#9;entryData := data[offset : offset+32]&#10;&#10;&#9;&#9;// Check for End of Catalog&#10;&#9;&#9;if entryData[0] == 0x00 {&#10;&#9;&#9;&#9;if et.Logger != nil {&#10;&#9;&#9;&#9;&#9;et.Logger.Debug(&quot;End of El Torito Boot Catalog reached&quot;, &quot;offset&quot;, offset)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;break&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Handle Section Headers&#10;&#9;&#9;if entryData[0] == 0x90 || entryData[0] == 0x91 {&#10;&#9;&#9;&#9;sectionCount = int(binary.LittleEndian.Uint16(entryData[2:4]))&#10;&#9;&#9;&#9;if et.Logger != nil {&#10;&#9;&#9;&#9;&#9;et.Logger.Debug(&quot;Section header found&quot;, &quot;offset&quot;, offset, &quot;entries&quot;, sectionCount)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Parse Section Entries&#10;&#9;&#9;if sectionCount &gt; 0 {&#10;&#9;&#9;&#9;entry := parseSectionEntry(entryData)&#10;&#9;&#9;&#9;if et.Logger != nil {&#10;&#9;&#9;&#9;&#9;et.Logger.Trace(&quot;Parsed section entry&quot;, &quot;entry&quot;, entry)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;et.Entries = append(et.Entries, entry)&#10;&#9;&#9;&#9;sectionCount--&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Parse Initial/Default Entry&#10;&#9;&#9;entry := parseInitialEntry(entryData)&#10;&#9;&#9;if et.Logger != nil {&#10;&#9;&#9;&#9;et.Logger.Trace(&quot;Parsed initial entry&quot;, &quot;entry&quot;, entry)&#10;&#9;&#9;}&#10;&#9;&#9;et.Entries = append(et.Entries, entry)&#10;&#9;}&#10;&#9;if et.Logger != nil {&#10;&#9;&#9;et.Logger.Debug(&quot;Total El Torito entries discovered&quot;, &quot;count&quot;, len(et.Entries))&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;// ElToritoEntry represents a single entry in an El-Torito boot catalog.&#10;type ElToritoEntry struct {&#10;&#9;Platform      Platform      // Target platform&#10;&#9;Emulation     Emulation     // Emulation mode&#10;&#9;BootFile      string        // Path to the boot file&#10;&#9;HideBootFile  bool          // Whether to hide the boot file in the filesystem&#10;&#9;LoadSegment   uint16        // Open segment address&#10;&#9;PartitionType PartitionType // Partition type of the boot file&#10;&#9;size          uint16        // Size of the boot file in 512-byte blocks&#10;&#9;location      uint32        // Location of the boot file in 2048-byte sectors&#10;}&#10;&#10;// SectionHeader represents a header for grouping entries in the boot catalog.&#10;type SectionHeader struct {&#10;&#9;Indicator byte     // Indicator byte (0x90 or 0x91 for the last section)&#10;&#9;Platform  Platform // Target platform&#10;&#9;Entries   uint16   // Number of entries in the section&#10;}&#10;&#10;// SelectionCriteria represents optional vendor-specific selection criteria.&#10;type SelectionCriteria struct {&#10;&#9;Type       byte   // Selection criteria type&#10;&#9;VendorData []byte // Vendor-specific data&#10;}&#10;&#10;// ValidationEntry represents the validation entry at the start of the boot catalog.&#10;type ValidationEntry struct {&#10;&#9;Platform    Platform // Target platform&#10;&#9;Identifier  string   // Identifier string&#10;&#9;Checksum    uint16   // Validation checksum&#10;&#9;KeyByte55AA uint16   // Fixed 0x55AA marker&#10;}&#10;&#10;// BuildBootImageEntries constructs a list of FileSystemEntry objects for all boot images.&#10;func (et *ElTorito) BuildBootImageEntries() ([]*filesystem.FileSystemEntry, error) {&#10;&#9;var entries []*filesystem.FileSystemEntry&#10;&#10;&#9;if et.Logger != nil {&#10;&#9;&#9;et.Logger.Debug(&quot;Building boot image entries for El Torito catalog&quot;)&#10;&#9;}&#10;&#10;&#9;for i, entry := range et.Entries {&#10;&#9;&#9;// Skip non-bootable entries&#10;&#9;&#9;if entry.size == 0 || entry.location == 0 {&#10;&#9;&#9;&#9;if et.Logger != nil {&#10;&#9;&#9;&#9;&#9;et.Logger.Trace(&quot;Skipping non-bootable entry&quot;, &quot;index&quot;, i, &quot;entry&quot;, entry)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Construct a synthetic file name for the boot image&#10;&#9;&#9;filename := fmt.Sprintf(&quot;%d-Boot-%s.img&quot;, i+1, entry.Emulation)&#10;&#10;&#9;&#9;// TODO: The directory should be user configurable, for now we use the same default as 7z&#10;&#9;&#9;// Create a FileSystemEntry for the boot image&#10;&#9;&#9;fsEntry := &amp;filesystem.FileSystemEntry{&#10;&#9;&#9;&#9;Name:       filename,&#10;&#9;&#9;&#9;FullPath:   &quot;/[BOOT]/&quot; + filename, // Logical path inside the ISO&#10;&#9;&#9;&#9;IsDir:      false,&#10;&#9;&#9;&#9;Size:       uint32(entry.size * 512), // Convert 512-byte block size&#10;&#9;&#9;&#9;Location:   entry.location,&#10;&#9;&#9;&#9;Mode:       0444,        // Read-only boot image&#10;&#9;&#9;&#9;CreateTime: time.Time{}, // No real timestamp in El Torito&#10;&#9;&#9;&#9;ModTime:    time.Time{},&#10;&#9;&#9;&#9;UID:        nil,&#10;&#9;&#9;&#9;GID:        nil,&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if et.Logger != nil {&#10;&#9;&#9;&#9;et.Logger.Trace(&quot;Boot image entry created&quot;, &quot;entry&quot;, fsEntry)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;entries = append(entries, fsEntry)&#10;&#9;}&#10;&#10;&#9;if et.Logger != nil {&#10;&#9;&#9;et.Logger.Debug(&quot;Total boot image entries built&quot;, &quot;count&quot;, len(entries))&#10;&#9;}&#10;&#10;&#9;return entries, nil&#10;}&#10;&#10;// ExtractBootImages extracts all bootable images to the specified directory.&#10;func (et *ElTorito) ExtractBootImages(ra io.ReaderAt, outputDir string) error {&#10;&#9;if et.Logger != nil {&#10;&#9;&#9;et.Logger.Debug(&quot;Extracting El Torito boot images to directory&quot;, &quot;outputDir&quot;, outputDir)&#10;&#9;}&#10;&#9;for i, entry := range et.Entries {&#10;&#9;&#9;// Skip non-bootable entries&#10;&#9;&#9;if entry.size == 0 || entry.location == 0 {&#10;&#9;&#9;&#9;if et.Logger != nil {&#10;&#9;&#9;&#9;&#9;et.Logger.Trace(&quot;Skipping non-bootable entry&quot;, &quot;index&quot;, i, &quot;entry&quot;, entry)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Create the file name&#10;&#9;&#9;filename := fmt.Sprintf(&quot;%d-Boot-%s.img&quot;, i+1, entry.Emulation)&#10;&#9;&#9;outputPath := filepath.Join(outputDir, filename)&#10;&#10;&#9;&#9;if et.Logger != nil {&#10;&#9;&#9;&#9;et.Logger.Debug(&quot;Extracting boot image&quot;, &quot;outputPath&quot;, outputPath)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Open the output file for writing&#10;&#9;&#9;outFile, err := os.Create(outputPath)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;if et.Logger != nil {&#10;&#9;&#9;&#9;&#9;et.Logger.Error(err, &quot;Failed to create file&quot;, &quot;outputPath&quot;, outputPath)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;failed to create file %s: %w&quot;, outputPath, err)&#10;&#9;&#9;}&#10;&#9;&#9;defer outFile.Close()&#10;&#10;&#9;&#9;// Read the boot image data&#10;&#9;&#9;startOffset := int64(entry.location) * int64(consts.ISO9660_SECTOR_SIZE)&#10;&#9;&#9;data := make([]byte, int64(entry.size)*512) // Size is in 512-byte blocks&#10;&#9;&#9;if _, err := ra.ReadAt(data, startOffset); err != nil {&#10;&#9;&#9;&#9;if et.Logger != nil {&#10;&#9;&#9;&#9;&#9;et.Logger.Error(err, &quot;Failed to read boot image&quot;, &quot;offset&quot;, startOffset)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;failed to read boot image at offset %d: %w&quot;, startOffset, err)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Write the data to the file&#10;&#9;&#9;if _, err := outFile.Write(data); err != nil {&#10;&#9;&#9;&#9;if et.Logger != nil {&#10;&#9;&#9;&#9;&#9;et.Logger.Error(err, &quot;Failed to write boot image&quot;, &quot;outputPath&quot;, outputPath)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;failed to write boot image to file %s: %w&quot;, outputPath, err)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Save the boot file path in the entry&#10;&#9;&#9;entry.BootFile = outputPath&#10;&#9;&#9;if et.Logger != nil {&#10;&#9;&#9;&#9;et.Logger.Debug(&quot;Boot image successfully extracted&quot;, &quot;outputPath&quot;, outputPath)&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;if et.Logger != nil {&#10;&#9;&#9;et.Logger.Debug(&quot;All boot images extraction complete.&quot;)&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;func IsElTorito(bootSystemIdentifier string) bool {&#10;&#9;trimmed := strings.TrimRight(bootSystemIdentifier, &quot;\x00&quot;)&#10;&#9;return trimmed == consts.EL_TORITO_BOOT_SYSTEM_ID&#10;}&#10;&#10;func parseInitialEntry(data []byte) *ElToritoEntry {&#10;&#9;return &amp;ElToritoEntry{&#10;&#9;&#9;Platform:      Platform(data[1]),&#10;&#9;&#9;Emulation:     Emulation(data[2]),&#10;&#9;&#9;LoadSegment:   binary.LittleEndian.Uint16(data[4:6]),&#10;&#9;&#9;PartitionType: PartitionType(data[4]),&#10;&#9;&#9;size:          binary.LittleEndian.Uint16(data[6:8]),&#10;&#9;&#9;location:      binary.LittleEndian.Uint32(data[8:12]),&#10;&#9;}&#10;}&#10;&#10;func parseSectionEntry(data []byte) *ElToritoEntry {&#10;&#9;return &amp;ElToritoEntry{&#10;&#9;&#9;Platform:      Platform(data[1]),&#10;&#9;&#9;Emulation:     Emulation(data[2]),&#10;&#9;&#9;LoadSegment:   binary.LittleEndian.Uint16(data[4:6]),&#10;&#9;&#9;PartitionType: PartitionType(data[4]),&#10;&#9;&#9;size:          binary.LittleEndian.Uint16(data[6:8]),&#10;&#9;&#9;location:      binary.LittleEndian.Uint32(data[8:12]),&#10;&#9;}&#10;}&#10;&#10;func parseValidationEntry(data []byte) error {&#10;&#9;if len(data) &lt; 32 {&#10;&#9;&#9;return fmt.Errorf(&quot;Validation Entry: data too short&quot;)&#10;&#9;}&#10;&#9;if data[0] != 0x01 {&#10;&#9;&#9;return fmt.Errorf(&quot;Validation Entry: invalid header ID %x&quot;, data[0])&#10;&#9;}&#10;&#9;checksum := uint16(0)&#10;&#9;for i := 0; i &lt; 32; i += 2 {&#10;&#9;&#9;checksum += binary.LittleEndian.Uint16(data[i : i+2])&#10;&#9;}&#10;&#9;if checksum != 0 {&#10;&#9;&#9;return fmt.Errorf(&quot;Validation Entry: checksum invalid&quot;)&#10;&#9;}&#10;&#9;if data[0x1E] != 0x55 || data[0x1F] != 0xAA {&#10;&#9;&#9;return fmt.Errorf(&quot;Validation Entry: invalid key bytes %x%x&quot;, data[0x1E], data[0x1F])&#10;&#9;}&#10;&#9;return nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>